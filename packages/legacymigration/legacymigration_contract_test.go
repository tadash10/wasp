// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0
package legacymigration_test

import (
	"os"
	"testing"

	"github.com/stretchr/testify/require"

	iotago "github.com/iotaledger/iota.go/v3"
	"github.com/iotaledger/wasp/packages/isc"
	"github.com/iotaledger/wasp/packages/kv/dict"
	"github.com/iotaledger/wasp/packages/legacymigration"
	"github.com/iotaledger/wasp/packages/origin"
	"github.com/iotaledger/wasp/packages/solo"
)

func init() {
	os.Setenv("GO_TESTING", "1")
}

func TestContract(t *testing.T) {
	env := solo.New(t)
	ch, _ := env.NewChainExt(nil, 0, "ch", dict.Dict{origin.ParamLegacyMigrationAdmin: isc.NewRandomAgentID().Bytes()})

	// fill the legacy migration contract with funds - must be >= the total tokens in the test csv
	contractAgentID := isc.NewContractAgentID(ch.ID(), legacymigration.Contract.Hname())
	err := ch.TransferAllowanceTo(isc.NewAssetsBaseTokens(50*isc.Million), contractAgentID, nil)
	require.NoError(t, err)

	// try a successful migration
	bundleHex, err := os.ReadFile("valid_bundle_example.hex")
	require.NoError(t, err)
	bundleBytes, err := iotago.DecodeHex(string(bundleHex))
	require.NoError(t, err)

	req := solo.NewCallParams(
		legacymigration.Contract.Name,
		legacymigration.FuncMigrate.Name,
		legacymigration.ParamBundle, bundleBytes,
	).WithMaxAffordableGasBudget()
	_, err = ch.PostRequestOffLedger(req, nil)
	require.NoError(t, err)
	rec := ch.LastReceipt()
	require.Nil(t, rec.Error)

	// try replaying that same migration
	_, err = ch.PostRequestOffLedger(req, nil)
	require.Error(t, err)
	// try sending no bundle
	reqNoBundle := solo.NewCallParams(
		legacymigration.Contract.Name,
		legacymigration.FuncMigrate.Name,
	).WithMaxAffordableGasBudget()
	_, err = ch.PostRequestOffLedger(reqNoBundle, nil)
	require.Error(t, err)

	// try sending invalid bundle
	reqBadBundle := solo.NewCallParams(
		legacymigration.Contract.Name,
		legacymigration.FuncMigrate.Name,
		legacymigration.ParamBundle, []byte("foobar"),
	).WithMaxAffordableGasBudget()
	_, err = ch.PostRequestOffLedger(reqBadBundle, nil)
	require.Error(t, err)
}

func TestWalletRsGeneratedBin(t *testing.T) {
	env := solo.New(t)
	ch, _ := env.NewChainExt(nil, 0, "ch", dict.Dict{origin.ParamLegacyMigrationAdmin: isc.NewRandomAgentID().Bytes()})

	// fill the legacy migration contract with funds - must be >= the total tokens in the test csv
	contractAgentID := isc.NewContractAgentID(ch.ID(), legacymigration.Contract.Hname())
	err := ch.TransferAllowanceTo(isc.NewAssetsBaseTokens(50*isc.Million), contractAgentID, nil)
	require.NoError(t, err)

	reqHex, err := os.ReadFile("wallet_rs_request_example.hex")
	require.NoError(t, err)
	reqBytes, err := iotago.DecodeHex(string(reqHex))
	require.NoError(t, err)

	// this is an UNSIGNED request generated by wallet.rs
	req, err := isc.RequestFromBytes(reqBytes)
	require.NoError(t, err)
	require.Error(t, req.(isc.OffLedgerRequest).VerifySignature()) // signature is not valid (but bundle IS)

	// no balance on the "target address"
	addr, err := iotago.ParseEd25519AddressFromHexString("0x7ad1aee6262b8823aa74177692d917f2603c30587df6916f666eeb692f22b38d")
	require.NoError(t, err)
	require.Zero(t, env.L1Assets(addr).BaseTokens)

	env.AddRequestsToMempool(ch, []isc.Request{req})
	ch.WaitUntilMempoolIsEmpty()

	receipt, err := ch.GetRequestReceipt(req.ID())
	require.NoError(t, err)
	require.NotNil(t, receipt)
	require.Nil(t, receipt.Error)

	// assert funds arrived on L1
	require.Greater(t, env.L1Assets(addr).BaseTokens, uint64(0))
}
